# React
### Virtual Dom 
Virtual Dom은 UI의 이상적인 또는 **가상**적인 표현을 메모리에 저장하고
ReactDOM과ㅓ 같은 라이브러리에 **실제** DOM과 동기화하는 프로그래밍 개념
이 과정을 재조정이라합니다.

이 접근방식이 리액트의 선언적 API를 가능하게 합니다.

- **리액트에 원하는 UI의 상태를 알려주면 DOM이 그 상태와 일치하도록 합니다.**

이러한 방식은 앱 구축에 사용해야 하는 어트리뷰트 조작, 이벤트 처리, 수동DOM 업데이트를 추상화합니다.

- 요약
  - 가상 돔을 사용하면 실제 돔에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용합니다.
  ### 실제 DOM의 가벼운 사본
  ```
  DOM의 상태를 메모리에 저장하고, 변경 전과 변경 후의 상태를 비교한 뒤
  최소한의 내용만 반영 하는 기능 => 성능 향상

  가상 DOM은 DOM의 상태를 메모리 위에 계속 올려두고,
  DOM에 변경이 있을 경우 해당 변경을 반영합니다.
  ```

### 참고
- [공식문서](https://ko.reactjs.org/docs/faq-internals.html)
- [티스토리](https://dev-cini.tistory.com/11)

---
### DOM
브라우저는 화면을 그리기 위해 DOM(Document Object Model)이라는 개념을 사용합니다.
DOM은 HTML 파일 내용을 토대로 만들어지는데,
자바스크립트와 같은 스크립팅 언어로 수정할 수 잇도록 만들어진, 웹 페이지의 객체 지향 표현입니다.
DOM은 브라우저가 화면을 그리기 위해서 필요한 정보가 트리 형태로 저장된 데이터입니다.
---
### 가상 DOM
실제 DOM에는 브라우저가 화면을 그리는데 필요한 모든 정보가 들어있어
실제 DOM을 조작하는 작업은 무겁습니다.
그래서 **리액트는 실제 DOM의 변경 사항을 빠르게 파악하고 반영하기 위해 내부적으로 가상 DOM을 만들어서 관리합니다.**
가상DOM은 일종의 DOM의 메타데이터, DOM의 요약본이라 할 수 있습니다.

DOM을 조작했을 때, DOM에 변화가 생기면, 렌더트리를 재생성하고
레이아웃을 만들고 페인팅을 하는 과정이 반복됩니다.
복잡한 SPA에서는 DOM 조작이 많이 발생하는데 변화를 적용하기 위해 브라우저가
많이 연산을 해야하고 전체적인 프로세스를 비효율적으로 만듭니다.
이 때, 가상 DOM을 사용한다면
뷰가 변화가 있을 때, 실제 DOM에 적용하기 전에 가상의 DOM에 먼저 적용시키고 그 최종적인 결과를
실제 DOM으로 전달해줍니다.
브라우저 내에서 발생하는 연산의 양을 줄이면서 성능이 개선되는 것입니다.
### 참고
- [벨로퍼트님](https://velopert.com/3236)
- [벨로그](https://velog.io/@gwak2837/React-Virtual-DOM-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
---
### DOM은 느린가요?
DOM 자체는 빠릅니다.
읽고 쓸 때의 성능은 자바스크립트 객체를 처리 할 때의 성능과 비교하여 다르지 않습니다.

**하지만** 웹 브라우저 단에서 DOM 변화가 일어나면 웹브라우저가 CSS를 다시 연산하고
레이아웃을 구성하고, 페이지를 리 페인트 즉, 렌더링이 일어나는 과정에서 시간이 허비됩니다.
그리고 이 렌더링 과정은 상황에 따라 여러번 반복하여 발생할 수 있고,
돔이 추가, 삭제 혹은 태그 위치가 변하는 경우 렌더링이 일어납니다.

속도적인 부분과 많은 일을 수행하다 버그가 발생하거나 브라우저가 죽는 일 등등의 일을 개선하고자
나온 것이 가상돔입니다.
### 참고
- [티스토리](https://dev-cini.tistory.com/10)
---
### 리액트가 가상 돔을 반영하는 절차
1. 데이터가 업데이트 되면, 전체 UI를 가상 돔에 리렌더링합니다.
2. 이전 가상 돔에 있던 내용과 현재의 내용을 비교합니다.(가상 돔 끼리 비교)
3. 바뀐 부분만 실제 돔에 적용이 됩니다.
- 요약
  - 작은 규모의 레이아웃이 여러번 발생하는 것보다
  큰 규모의 레이아웃이 한 번 발생하는 것은 성능상의 큰 차이를 나타냅니다.
  리액트는 얕은 비교와 일괄 돔 업데이트 방식을 이용해 성능 향상을 이끕니다.
### 참고
- [티스토리](https://dev-cini.tistory.com/11)
--- 
### 참고하면 좋을만한 블로그
- [DOM을 코드와 함께 예시](https://doqtqu.tistory.com/316)
---
# 가장 중요한 것
1. DOM의 상태를 메모리에 저장하고 변경 전과 변경 후의 상태를 비교한 뒤
   최소한의 내용만 반영하는 기능 -> 성능 향상
2. 가상 돔은 돔의 상태를 메모리 위에 계속 올려두고 DOM에 변경이 있을 때만 해당 변경을 반영합니다.
---
# useState
- State Hook은 함수형 컴포넌트가 클래스형 컴포넌트처럼 **지역 상태**를 가질 수 있도록 한다.

### 버튼 클릭시마다 화면에 표시되는 숫자가 1씩 증가하는 카운터를 렌더링하는 예시
```jsx
import {useState, useCallback} from 'react';

const Example = () => {
  const [count, setCount] = useState(0);

  const handleCount = useCallback(() => {
    setCount(count + 1);
  },[count])

  return(
    <>
      <p>{count}만큼 클릭되었습니다.</p>
      <button onClick={handleCount}>클릭</button>
    </>
  )
}
```
useState() 함수를 이용하면 함수형 컴포넌트에서 **지역 상태**를 저장할 수 있다.
리액트는 이 상태 값을 렌더링 간에 유지한다.
useState()함수가 반환하는 배열의 
첫 번째 요소는 해당 상태의 값,
두 번째 요소는 해당 상태를 설정하기 위한 함수이다.
useState() 함수의 인자로 전달하는 값은 해당 상태의 초깃값으로, **첫 번째 렌더링 시에만 사용된다**

여러 개의 state 변수를 선언하려면 다음과 같이 useState() 함수를 여러 번 호출하면 된다.
```jsx
const Example = () => {
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState('banana');
  const [todos, setTodos] = useState([{text : 'Learn React'}]);
}
```

구조 분해 할당 문법은 useState()함수에 의해 반환된 각각의 상태 값에 서로 다른 변수명을 할당할 수 있도록 해준다.
**useState()함수를 여러 번 호출하는 경우 그 호출 순서는 반드시 매 렌더링마다 같게 해야 한다.**
### 참고
- [티스토리](https://it-eldorado.tistory.com/98)
### useState는 비동기인가?
- useState는 비동기적으로 동작한다.
- 하나의 이벤트 핸들러 함수 내에서 같은 setState가 호출된다면 마지막에 실행한 setState가 실행되어 렌더링 된다.
```jsx
import {useState} from 'react';

const Example = () => {
  const [count, setCount] = useState(0);

  const onClick = () => {
    setCount(count + 1); // setState 실행1 <- 실행 안함
    console.log(count);
    
    setCount(count+1.5); // setState 실행2 <- 실행
    console.log(count);
  }

  return(
    <>
    <p>{count}</p>
    <button onClick={onClick}>+</button>
    </>
  )
}
```

위의 코드를 실행하면 결괏값이 비동기적으로 동작하기 때문에
1.5씩만 증가한다.

동일한 state를 연속적으로 업데이트하는 경우,
모든 요청에 따라 setState를 각각 동기로 수행 후 바로 리렌더링하는 것이 아니라
**변경 사항을 모아서 한  번에 일괄처리를 하기 때문이다.**
전달된 setState를 하나로 병합한 후
최종적으로 한 번의 setState를 하게 되어 **결국 마지막 명령만 수행**하게 된다.

이렇게 일괄적인 batch update를 통해서 컴포넌트의 렌더링 횟수를 최소화하여
불필요한 렌더링을 방지하고 더 빠른 속도로 동작하게끔 한다.
### 참고
- [티스토리](https://goddino.tistory.com/326)
---
# 불변성이란 무엇이고, 왜 지켜야할까?
함수형 프로그래밍의 특징 중 하나가 순수함수를 사용하는 것입니다.
여기서 순수함수란 동일한 매개변수를 넣었을 때 동일한 리턴값을 출력하는 것입니다.
동시에 순수함수는 외부의 값을 변경하는 사이드 이펙트가 일어나지 않는 조건을 지키는 함수를 뜻합니다.
여기서 **외부의 값을 변경하지 않는다는 부분이 불변성과 연관된 부분입니다.**

### 불변성이란 무엇일까
자바스크립트의 원시타입을 통해 불변성을 설명하겠습니다.
```js
let string = '1' // 1. string: '1'가 메모리 영역 1에 등록됩니다.
string = '2' // 2. string: '2'가 메모리 영역 2에 등록됩니다.
```
위 예시에서 메모리 영역을 총 2개 사용했습니다.
변수 string은 '1' 이었고, 여기에 '2'를 할당하였는데
기존 메모리 영역 1에 있는 '1'의 값은 그대로 두고,
메모리 영역 2에 '2'를 새로 할당했습니다.

즉, 메모리 영역에서 '2'는'1'을 대체하는 것이 아니라 새로운 영역에 할당됩니다.
이게 불변성입니다.

원시타입도 마찬가지입니다.
```js
let array = [1,2,3,4,5] // 메모리영역 1
array.push(6) // 메모리영역 1

array = [1,2,3,4] // 메모리영역 2 (새로운 참조값) 
```
array.push(5)는 원본데이터를 수정함으로써 불변성을 지켜주지 않은 것이 되고,
array=[1,2,3,4]는 새로운 배열 [1,2,3,4]을 할당하고 새로운 참조값을 만들어주어 불변성을
지켜준 것이 됩니다.

불변성의 진짜 의미는 **메모리 영역에서 값을 변경할 수 없다**는 의미입니다.
### 왜 리액트에서 불변성을 지켜야 하나?
리액트에서 불변성을 지켜주는 이유는 리액트가 상태 업데이트를 하는 원리 때문입니다.
리액트는 상태값을 업데이트 할 때 얕은 비교를 수행합니다.
객체의 속성 하나하나를 비교하는게 아니라 참조값만 비교하여 상태 변화를 감지합니다.

1. 효율적인 상태 업데이트
- 얕은 비교란 객체의 프로퍼티를 하나하나 다 비교하지 않고, 객체의 참조 주소값만 변경되었는지 확인합니다. 얕은 비교는 계산 리소스를 줄여주기 때문에 리액트는 효율적으로 상태를 업데이트 할 수 있습니다.
2. 사이드 이펙트 방지 및 프로그래밍 구조의 단순성
- 원시타입은 애시당초 불변성 특징을 가지고 있지만 참조타입인 객체나 배열의 경우 새로운 값을 변경할 때 원본데이터가 변경이 됩니다. 이렇게 원본 데이터가 변경될 경우, 이 원본 데이터를 참조하고 있는 다른 객체에서 예상치 못한 오류가 발생할 수 있습니다. 프로그래밍의 복잡도가 올라갑니다.
### 어떻게 불변성을 지키는가?
스프레드 연산자, map, filter, slice, reduce등 등 새로운 배열을 반환하는 메소드들을 활용하면 됩니다.
```jsx
// 원시 타입
const [number, setNumber] = useState(0);
setState(3)
// 참조 타입
const [person, setPerson] = useState({name: '', age:30});
setState({...person, name: 'pyo'});
```
### 참고
- [티스토리](https://hsp0418.tistory.com/171)
---
# 생명주기
### 함수형 컴포넌트 생명주기
- 생명주기 순서 요약
  1. 함수형 컴포넌트가 호출이 됩니다.
  2. 함수형 컴포넌트의 내부에서 실행합니다.
  3. return()으로 화면에 렌더링 합니다.
  4. useEffect()가 실행됩니다.
- 조건부 수행
  - 변경 혹은 컴포넌트의 소멸이 발생 시 useEffect() 실행