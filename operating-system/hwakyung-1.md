# 운영체제 개념 정리

## 프로세스와 쓰레드

### ✅ 프로세스

- 정의 : 프로그램을 메모리에 올린 동적인 상태로 프로그램이 실행될 때 프로세스 인스턴스가 생성된다고 표현
  - **OS가 프로그램을 메모리에 올리고 CPU를 위한 PCB(Process control block)을 할당한 상태**
- 프로그램 입장 : 프로그램 + PCB
- 스케줄러 입장 : task

### ✅ 쓰레드

- 정의 : CPU에서 처리하는 실행 하나가 스레드
  - 작업 처리 위해 수행하는 **실행** 단위
- CPU는 프로세스로부터 전달받은 스레드 수행
- OS 입장
  - 작업 = 프로세스
  - CPU의 작업 = 프로세스 내의 스레드

### ✅ 프로세스와 쓰레드와의 차이

1. 동시 작업, 시스템 자원을 멀티 스레드가 더 적게 사용
2. 프로세스 간 통신은 스레드 보다 복잡
3. 스레드의 동기화 이슈

- 프로세스 : 메모리에 올라갈 때 운영체제로부터 시스템 자원을 할당 받음

  - 운영체제는 프로세스마다 독립된 메모리 영역을 Code/Data/Stack/Heap 형식을 할당

- 스레드 : 프로세스가 할당받은 메모리 영역 내의 Stack 형식으로 할당된 메모리 영역은 따로 할당받고, 나머지는 code/data/heap 형식으로 할당된 메모리 영역 공유

#### 프로세스와 쓰레드의 작동 방식

- 프로세스 : 독립된 메모리 영역을 할당해 줌 -> 프로세스는 다른 프로세스의 변수나 자료에 접근 x

- 스레드 : 별도의 스택을 가지고 있지만 힙 메모리는 서로 읽고 쓸 수 있음

- 프로세스 실행 중 오류 발생 -> 강제 종료 시 다른 프로세스에게 어떤 영향?
  - 공유하고 있던 파일을 손상시키는 경우가 아니면 영향 X
- 스레드의 경우 메모리 영역의 내용 공유 -> 오류 발생 시 => 다른 스레드도 강제 종료

### 왜 이런 방식으로 메모리 공유?

- 운영체제에게 프로세스는 최소 작업 단위
- 프로세스는 하나 이상의 스레드 보유
- 프로세스가 최소 작업 단위 -> 동일 프로세스 소속의 스레드끼리 메모리를 공유함

### ✅ 기출문제

- Q. 프로세스와 쓰레드의 차이?
  - 프로세스는 독립된 메모리가 할당됨
  - 쓰레드는 별도의 스택이 주어지지만 나머지 힙 메모리는 공유됨
- Q. 프로세스의 문제점
  - 프로세스 생성 시 큰 오버헤드
  - 컨텍스트 스위칭의 비효율성
  - 프로세스 간의 통신이 어려운점
- Q. 쓰레드의 출현 목적
  - 1. 프로세스보다 크기가 작은 실행 단위 필요
  - 2. 빠른 컨텍스트 스위칭
  - 3. 프로세스의 생성 및 소멸에 따른 오버헤드 감소
  - 4. 프로세스들의 통신 시간, 방법 어려움 해소
  - 자원 효율성과 작업 유연성
  - 1. 응답성 향상 : 다른 스레드들이 작업 계속 응답 가능
  - 2. 자원의 공유 : 불필요한 자원 중복 막아짐
  - 3. 다중 CPU 지원 시 멀티 스레드로 처리 가능
- Q. 쓰레드의 주소공간에 대한 설명
  - 쓰레드 동작을 위한 총 6개의 공간
    - 사적 공간
      - 스레드 코드 영역 : 스레드가 실행할 작업의 함수가 있으며 스레드는 프로세스 코드 영역에 있느 ㄴ다른 모든 함수를 호출 할 수 있음
      - 스레드 로컬 스토리지
      - 스레드 사용자 스택 : 프로세스 스택의 일부분을 할당
    - 공유 공간
      - 프로세스에 선언된 함수 코드
      - 데이터 : 개별 스레드 전용 공간인 스레드 로컬 스토리지와 프로세스에 의해 공유되는 변수 공간
      - 힙 : 모든 스레드가 동적 할당을 받는 공간으로 프로세스이 힙 공간 사용
    - 커널 스택
- Q. 멀티 태스킹과 멀티 스레드
  - 멀티 태스킹
    - 하나의 운영체제 안에 여러 프로세스가 실행
  - 멀티 스레드
    - 하나의 프로세스가 여러 스레드를 사용하여 동시 처리
    - 장점
      - 1. context switching 할 때 공유하고 있는 메모리 만큼의 메모리 자원을 아낄 수 있음
      - 2. 스레드는 프로세스 내의 stack 영역을 제외한 모든 메모리 공유 -> 통신의 부담이 적어 응답 시간이 빠름
    - 단점
      - 1. 스레드가 프로세스 자원 망칠 시, 모든 프로세스 종류
      - 2. 자원 공유로 동기화 문제 발생
    - 동기화 문제
      - 전역 변수를 사용할 경우 발생할 수 있는 충돌
      - 프로그래머가 직접 동기화 문제를 대응해야 함
- Q. 다른 프로세스 접근 방법
  - 1. IPC
  - 2. LPC
  - 3. 별도 공유 메모리 생성 및 정보 공유

## 페이징과 세그멘테이션

### ✅ 페이징의 정의

- 세그멘테이션과 가상 메모리를 고정된 크기로 나누고 메모리를 관리하는 것

### ✅ 세그멘테이션의 정의

- 메모리를 서로 크기가 다른 논리적인 블록 단위인 세그먼트로 분할 -> 메모리 할당 및 물리 주소를 논리 주소로 변환하는 거

### ✅ 페이징과 세그멘테이션의 공통점

- 프로그램을 실행하기 위해 디스크의 내용을 분할 및 메모리에 적재하는 불연속 메모리 관리 기법

### ✅ 페이징과 세그멘테이션의 차이점

- 프로그램을 분할하는 방식
- 1. 페이지는 고정 블록 크기, 세그먼트는 가변 크기
- 2. 페이징은 고정 블록 크기 -> 내부 단편화, 메모리가 가변 크기 블록으로 적재되어 세그멘테이션에서는 외부 조각이 발생할 수 있음
- 3. 페이지의 크기는 하드웨어에 의해 결정, 세그먼트는 사용자가 지정
- 4. 페이징의 페이지 테이블은 논리 주소를 실제 주소에 매핑 , 세그먼트에서는 세그먼트 테이블이 논리 주소를 실제 주소로 매핑
- 5. 페이징에서 페이지 번호와 오프셋으로 나뉜 주소로만 하나의 정수 제공, 세그먼트에서는 세그먼트의 수와 오프셋의 두 개의 수로 주소 지정

### ✅ 기출문제

**Q. 메모리 단편화란?**

- 메모리의 공간을 여러 개로 나뉘어 사용할 때, 충분히 사용 가능한 메모리가 있음에도 불구하고 할당을 못하는 상태

**Q. 외부 단편화와 내부 단편화란?**

- 외부 단편화
  - 메모리 할당/해제 작업 시 사용 가능한 공간이 존재하여 전체적으로 사용 가능한 메모리의 양은 충분하나 실제로 메모리를 할당할 수 없는 상태
- 내부 단편화
  - 메모리 할당하는 최소 블록의 크기에 비해 작업에 필요한 메모리의 양이 작은 경우, 남은 공간이 생겨 메모리 낭비하게 되는 상황

**Q. 외부 단편화를 해결하는 페이징 기법에 대한 설명**

- 프레임 : 램을 일정한 크기의 블록으로 나눈 것
- 페이징 : 논리 메모리 또는 가상 메모리를 일정 크기의 블록으로 나눈 것

- 페이징 기법 : 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법
  - page mapping에 사용을 위한 page table을 생성
  - 연속적이지 않던 공간을 연속적으로 활용 가능
  - mapping이 늘어나는 단점 발생

**Q. 내부 단편화를 해결하는 세그멘테이션 기법 설명**

- 가상 메모리를 서로 크기가 다른 세그먼트를 논리적 단위로 분할 및 사용하는 기법
- 세그먼트 테이블 : 세그먼트 번호, 시작 주소, 세그먼트 크기
- 1. CPU가 세그먼트 테이블에게 테이블 번호, 메모리 크기 전달
- 2. 세그먼트 테이블은 메모리로 가 해당 테이블의 번호 base와 limit를 비교
- 3. limit보다 메모리 공간이 작으면 인터럽트 발생
- 4. 강제 종료
- 세그멘테이션 기법은 크기가 다양한 만큼 메모리 낭비 존재 -> 페이징 기법을 더 많이 사용

## 뮤텍스와 세마포어

### ✅ 뮤텍스의 정의

- 상호배제, 임계 영역을 가진 쓰레드들의 Running Time이 서로 겹치지 않게 각각 단독으로 실행하게 하는 기술
- 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 locking과 unlocking 사용
- 뮤텍스 객체를 두 쓰레드가 동시 사용 x

#### 뮤텍스 코드

- 공유 자원 점유한 프로세스가 락 보유
- 자원 사용 마치면 락 반납

```c
// P and V
wait(S) {
    while (S <= 0);
    S--;
}
signal(S) {
    S++;
}

// Mutex implementation in binary semaphore
do {
    wait(&mutex);
    /* Critical Section */
    signal(&mutex);
    /* Remainder Section */
} while (true);
```

_출처: https://rebas.kr/857 [PROJECT REBAS:티스토리]_

### ✅ 세마포어의 정의

- 리소스의 상태를 나타내는 간단한 카운터
- 특정 프로세스가 공유 자원 사용중 -> 다른 프로세스가 공유 자원을 사용하지 못하도록 함
- P 연산 : wait/ 자원을 사용하려는 프로세스들의 진입 엽무를 자원 카운트(S)를 통해 결정, 카운트를 감소 시켜, 자원 점유 알림
- V 연산 : Signal 동작/ 대기 중인 프로세스를 깨우는 신호, 카운트 증가(S++) 자원 반납을 알림

#### 세마포어 코드

-

```C
// P and V
wait(S) {
    while (S <= 0);
    S--;
}
signal(S) {
    S++;
}

// Mutex implementation in binary semaphore
do {
    wait(&mutex);
    /* Critical Section */
    signal(&mutex);
    /* Remainder Section */
} while (true);

```

_출처: https://rebas.kr/857 [PROJECT REBAS:티스토리]_

### ✅ 뮤텍스와 세마포어의 공통점

- 여러 개의 프로세스가 동시 접근하면서 문제 발생 -> 안전하게 관리하기 위해 상호배제를 달성하는 기법
- 세마포어와 뮤텍스 = 상호배제 달성을 위한 기법

### ✅ 뮤텍스와 세마포어의 차이점

1. 세마포어는 뮤텍스가 될 수 있으나 뮤텍스는 세마포어가 될 수 없음
2. 세마포어는 소유 x, 뮤텍스는 소유 가능
3. 뮤텍스를 소유하고 있는 쓰레드가 뮤텍스 해제 가능, 세마포어의 경우 세마포어를 소유하지 않는 쓰레드가 세마포어 해제 가능
4. 세마포어는 시스템 범위에 걸쳐있고 파일 형태로 존재, 뮤텍스는 프로세스 범위이며 프로세스 종료될 때 자동으로 clean up

**가장 큰 차이: 동기화 대상의 개수**

- 뮤텍스 : 동기화 대상이 오직 하나
- 세마포어: 동기화 대상이 하나 이상

### ✅ 기출문제

Q. 뮤텍스와 세마포어 차이

- 동기화 대상의 개수에 따라 차이가 나며 동기화 대상이 하나이면 뮤텍스, 동기화 대상이 하나 이상이면 세마포어이다
