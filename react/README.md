# React
### Virtual Dom 
Virtual Dom은 UI의 이상적인 또는 **가상**적인 표현을 메모리에 저장하고
ReactDOM과ㅓ 같은 라이브러리에 **실제** DOM과 동기화하는 프로그래밍 개념
이 과정을 재조정이라합니다.

이 접근방식이 리액트의 선언적 API를 가능하게 합니다.

- **리액트에 원하는 UI의 상태를 알려주면 DOM이 그 상태와 일치하도록 합니다.**

이러한 방식은 앱 구축에 사용해야 하는 어트리뷰트 조작, 이벤트 처리, 수동DOM 업데이트를 추상화합니다.

- 요약
  - 가상 돔을 사용하면 실제 돔에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용합니다.
  ### 실제 DOM의 가벼운 사본
  ```
  DOM의 상태를 메모리에 저장하고, 변경 전과 변경 후의 상태를 비교한 뒤
  최소한의 내용만 반영 하는 기능 => 성능 향상

  가상 DOM은 DOM의 상태를 메모리 위에 계속 올려두고,
  DOM에 변경이 있을 경우 해당 변경을 반영합니다.
  ```

### 참고
- [공식문서](https://ko.reactjs.org/docs/faq-internals.html)
- [티스토리](https://dev-cini.tistory.com/11)

---
### DOM
브라우저는 화면을 그리기 위해 DOM(Document Object Model)이라는 개념을 사용합니다.
DOM은 HTML 파일 내용을 토대로 만들어지는데,
자바스크립트와 같은 스크립팅 언어로 수정할 수 잇도록 만들어진, 웹 페이지의 객체 지향 표현입니다.
DOM은 브라우저가 화면을 그리기 위해서 필요한 정보가 트리 형태로 저장된 데이터입니다.
---
### 가상 DOM
실제 DOM에는 브라우저가 화면을 그리는데 필요한 모든 정보가 들어있어
실제 DOM을 조작하는 작업은 무겁습니다.
그래서 **리액트는 실제 DOM의 변경 사항을 빠르게 파악하고 반영하기 위해 내부적으로 가상 DOM을 만들어서 관리합니다.**
가상DOM은 일종의 DOM의 메타데이터, DOM의 요약본이라 할 수 있습니다.

DOM을 조작했을 때, DOM에 변화가 생기면, 렌더트리를 재생성하고
레이아웃을 만들고 페인팅을 하는 과정이 반복됩니다.
복잡한 SPA에서는 DOM 조작이 많이 발생하는데 변화를 적용하기 위해 브라우저가
많이 연산을 해야하고 전체적인 프로세스를 비효율적으로 만듭니다.
이 때, 가상 DOM을 사용한다면
뷰가 변화가 있을 때, 실제 DOM에 적용하기 전에 가상의 DOM에 먼저 적용시키고 그 최종적인 결과를
실제 DOM으로 전달해줍니다.
브라우저 내에서 발생하는 연산의 양을 줄이면서 성능이 개선되는 것입니다.
### 참고
- [벨로퍼트님](https://velopert.com/3236)
- [벨로그](https://velog.io/@gwak2837/React-Virtual-DOM-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
---
### DOM은 느린가요?
DOM 자체는 빠릅니다.
읽고 쓸 때의 성능은 자바스크립트 객체를 처리 할 때의 성능과 비교하여 다르지 않습니다.

**하지만** 웹 브라우저 단에서 DOM 변화가 일어나면 웹브라우저가 CSS를 다시 연산하고
레이아웃을 구성하고, 페이지를 리 페인트 즉, 렌더링이 일어나는 과정에서 시간이 허비됩니다.
그리고 이 렌더링 과정은 상황에 따라 여러번 반복하여 발생할 수 있고,
돔이 추가, 삭제 혹은 태그 위치가 변하는 경우 렌더링이 일어납니다.

속도적인 부분과 많은 일을 수행하다 버그가 발생하거나 브라우저가 죽는 일 등등의 일을 개선하고자
나온 것이 가상돔입니다.
### 참고
- [티스토리](https://dev-cini.tistory.com/10)
---
### 리액트가 가상 돔을 반영하는 절차
1. 데이터가 업데이트 되면, 전체 UI를 가상 돔에 리렌더링합니다.
2. 이전 가상 돔에 있던 내용과 현재의 내용을 비교합니다.(가상 돔 끼리 비교)
3. 바뀐 부분만 실제 돔에 적용이 됩니다.
- 요약
  - 작은 규모의 레이아웃이 여러번 발생하는 것보다
  큰 규모의 레이아웃이 한 번 발생하는 것은 성능상의 큰 차이를 나타냅니다.
  리액트는 얕은 비교와 일괄 돔 업데이트 방식을 이용해 성능 향상을 이끕니다.
### 참고
- [티스토리](https://dev-cini.tistory.com/11)
--- 
### 참고하면 좋을만한 블로그
- [DOM을 코드와 함께 예시](https://doqtqu.tistory.com/316)
---
# 가장 중요한 것
1. DOM의 상태를 메모리에 저장하고 변경 전과 변경 후의 상태를 비교한 뒤
   최소한의 내용만 반영하는 기능 -> 성능 향상
2. 가상 돔은 돔의 상태를 메모리 위에 계속 올려두고 DOM에 변경이 있을 때만 해당 변경을 반영합니다.
---
# useState
- State Hook은 함수형 컴포넌트가 클래스형 컴포넌트처럼 **지역 상태**를 가질 수 있도록 한다.

### 버튼 클릭시마다 화면에 표시되는 숫자가 1씩 증가하는 카운터를 렌더링하는 예시
```jsx
import {useState, useCallback} from 'react';

const Example = () => {
  const [count, setCount] = useState(0);

  const handleCount = useCallback(() => {
    setCount(count + 1);
  },[count])

  return(
    <>
      <p>{count}만큼 클릭되었습니다.</p>
      <button onClick={handleCount}>클릭</button>
    </>
  )
}
```
useState() 함수를 이용하면 함수형 컴포넌트에서 **지역 상태**를 저장할 수 있다.
리액트는 이 상태 값을 렌더링 간에 유지한다.
useState()함수가 반환하는 배열의 
첫 번째 요소는 해당 상태의 값,
두 번째 요소는 해당 상태를 설정하기 위한 함수이다.
useState() 함수의 인자로 전달하는 값은 해당 상태의 초깃값으로, **첫 번째 렌더링 시에만 사용된다**

여러 개의 state 변수를 선언하려면 다음과 같이 useState() 함수를 여러 번 호출하면 된다.
```jsx
const Example = () => {
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState('banana');
  const [todos, setTodos] = useState([{text : 'Learn React'}]);
}
```

구조 분해 할당 문법은 useState()함수에 의해 반환된 각각의 상태 값에 서로 다른 변수명을 할당할 수 있도록 해준다.
**useState()함수를 여러 번 호출하는 경우 그 호출 순서는 반드시 매 렌더링마다 같게 해야 한다.**
### 참고
- [티스토리](https://it-eldorado.tistory.com/98)
### useState는 비동기인가?
- useState는 비동기적으로 동작한다.
- 하나의 이벤트 핸들러 함수 내에서 같은 setState가 호출된다면 마지막에 실행한 setState가 실행되어 렌더링 된다.
```jsx
import {useState} from 'react';

const Example = () => {
  const [count, setCount] = useState(0);

  const onClick = () => {
    setCount(count + 1); // setState 실행1 <- 실행 안함
    console.log(count);
    
    setCount(count+1.5); // setState 실행2 <- 실행
    console.log(count);
  }

  return(
    <>
    <p>{count}</p>
    <button onClick={onClick}>+</button>
    </>
  )
}
```

위의 코드를 실행하면 결괏값이 비동기적으로 동작하기 때문에
1.5씩만 증가한다.

동일한 state를 연속적으로 업데이트하는 경우,
모든 요청에 따라 setState를 각각 동기로 수행 후 바로 리렌더링하는 것이 아니라
**변경 사항을 모아서 한  번에 일괄처리를 하기 때문이다.**
전달된 setState를 하나로 병합한 후
최종적으로 한 번의 setState를 하게 되어 **결국 마지막 명령만 수행**하게 된다.

이렇게 일괄적인 batch update를 통해서 컴포넌트의 렌더링 횟수를 최소화하여
불필요한 렌더링을 방지하고 더 빠른 속도로 동작하게끔 한다.
### 참고
- [티스토리](https://goddino.tistory.com/326)